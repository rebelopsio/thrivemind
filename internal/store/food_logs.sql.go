// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: food_logs.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createFoodLog = `-- name: CreateFoodLog :one
INSERT INTO food_logs (
    user_id,
    food_id,
    servings,
    meal_type,
    logged_at,
    notes
) VALUES (
             $1, $2, $3, $4, $5, $6
         ) RETURNING id, user_id, food_id, servings, meal_type, logged_at, notes, created_at
`

type CreateFoodLogParams struct {
	UserID   uuid.NullUUID  `json:"user_id"`
	FoodID   uuid.NullUUID  `json:"food_id"`
	Servings pgtype.Numeric `json:"servings"`
	MealType sql.NullString `json:"meal_type"`
	LoggedAt time.Time      `json:"logged_at"`
	Notes    sql.NullString `json:"notes"`
}

func (q *Queries) CreateFoodLog(ctx context.Context, arg CreateFoodLogParams) (FoodLog, error) {
	row := q.db.QueryRow(ctx, createFoodLog,
		arg.UserID,
		arg.FoodID,
		arg.Servings,
		arg.MealType,
		arg.LoggedAt,
		arg.Notes,
	)
	var i FoodLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FoodID,
		&i.Servings,
		&i.MealType,
		&i.LoggedAt,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getUserFoodLogs = `-- name: GetUserFoodLogs :many
SELECT
    fl.id, fl.user_id, fl.food_id, fl.servings, fl.meal_type, fl.logged_at, fl.notes, fl.created_at,
    f.name as food_name,
    f.calories,
    f.protein_g,
    f.carbs_g,
    f.fat_g
FROM food_logs fl
         JOIN foods f ON fl.food_id = f.id
WHERE fl.user_id = $1
  AND fl.logged_at >= $2
  AND fl.logged_at < $3
ORDER BY fl.logged_at DESC
`

type GetUserFoodLogsParams struct {
	UserID     uuid.NullUUID `json:"user_id"`
	LoggedAt   time.Time     `json:"logged_at"`
	LoggedAt_2 time.Time     `json:"logged_at_2"`
}

type GetUserFoodLogsRow struct {
	ID        uuid.UUID      `json:"id"`
	UserID    uuid.NullUUID  `json:"user_id"`
	FoodID    uuid.NullUUID  `json:"food_id"`
	Servings  pgtype.Numeric `json:"servings"`
	MealType  sql.NullString `json:"meal_type"`
	LoggedAt  time.Time      `json:"logged_at"`
	Notes     sql.NullString `json:"notes"`
	CreatedAt time.Time      `json:"created_at"`
	FoodName  string         `json:"food_name"`
	Calories  sql.NullInt32  `json:"calories"`
	ProteinG  pgtype.Numeric `json:"protein_g"`
	CarbsG    pgtype.Numeric `json:"carbs_g"`
	FatG      pgtype.Numeric `json:"fat_g"`
}

func (q *Queries) GetUserFoodLogs(ctx context.Context, arg GetUserFoodLogsParams) ([]GetUserFoodLogsRow, error) {
	rows, err := q.db.Query(ctx, getUserFoodLogs, arg.UserID, arg.LoggedAt, arg.LoggedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserFoodLogsRow{}
	for rows.Next() {
		var i GetUserFoodLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FoodID,
			&i.Servings,
			&i.MealType,
			&i.LoggedAt,
			&i.Notes,
			&i.CreatedAt,
			&i.FoodName,
			&i.Calories,
			&i.ProteinG,
			&i.CarbsG,
			&i.FatG,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
